#  06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？

MySQL的锁包括三种：全局锁、表锁和行锁。

行锁应该是InnoDB独有的。

本文单独讲全局锁和表锁。

## 全局锁

全局锁在备份全库的时候有用，但是这个会比较重，比较奇怪。

实际上，做全库备份的方法往往是基于MVCC的，mysqldump使用参数--single-transcation时，会启动一个事务，逻辑类似可重复读里面的创建视图。

## MySQL MVCC原理

这个这篇里面没讲，后面有提到，现在先简单介绍一下。

** InnoDB实现MVCC的方法是，它存储了每一行的三个额外的隐藏字段:**

```
1.DB_TRX_ID：一个6byte的标识，每处理一个事务，其值自动+1
#下面提到的“创建时间”和“删除时间”记录的就是这个DB_TRX_ID的值
#如insert、update、delete操作时，删除操作用1个bit表示。 
#DB_TRX_ID是最重要的一个，可以通过语句“show engine innodb status”来查找 


2.DB_ROLL_PTR: 大小是7byte,指向写到rollback segment（回滚段）的一条undo log记录
 （update操作的话，记录update前的ROW值）

3.DB_ROW_ID: 大小是6byte,该值随新行插入单调增加。
  #当由innodb自动产生聚集索引时聚集索引(即没有主键时,因为MYSQL默认聚簇表,会自动生成一个ROWID)
  #包括这个DB_ROW_ID的值，
  #不然的话聚集索引中不包括这个值,这个用于索引当中。
DB_TRX_ID记录了行的创建的时间删除的时间在每个事件发生的时候，每行存储版本号，而不是存储事件实际发生的时间。每次事物的开始这个版本号都会增加。自记录时间开始，每个事物都会保存记录的系统版本号。
依照事物的版本来检查每行的版本号。在insert操作时 “创建时间”=DB_TRX_ID，这时，“删除时间”是未定义的；在update时，复制新增行的“创建时间”=DB_TRX_ID，删除时间未定义，旧数据行“创建时间”不变，
删除时间=该事务DB_TRX_ID；delete操作，相应数据行的“创建时间”不变，删除时间=该事务的DB_ROW_ID；select操作对两者都不修改，只读相应的数据


```
 

## 表级锁


表锁包括两种：表锁和元数据锁。

表锁类似前面全局锁，需要手动控制，代价比较大，多用于MyIsam引擎。

元数据锁(meta data lock MDL)是InnoDB独有的，MDL不需要显示调用，访问一个表时自动会加上。

主要是防止做表结构修改时，导致查询不一致。

这里面提到了如何安全的修改表结构

## 安全的修改表结构

修改表结构时，会占用MDL写锁，会阻塞其它的写锁或者读锁。如果客户端有重试功能，多次重试，很快线程会爆满。

所以修改表结构是，要尽快提交事务，减少占用锁的时间。

对于热点表，要等到没有业务的时候执行。

## 问题

在主备结构中，如果主库做了DDL，备库会看到什么现象？



